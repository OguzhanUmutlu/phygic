class PhygicAnimator{animating=!1;method="timeout";speed=1;deltaSpeed=1;currentId;last=-1;_updates=[];constructor(t,e="timeout"){this.functions=Array.isArray(t)?t:[t],this.setUpdateMethod(e)}async __loop__(){const t=t=>"timeout"===this.method?setTimeout(t):requestAnimationFrame(t);if(this.speed>1||this.speed<=0)throw new Error("Animator speed should be between 0 and 1! Got: "+this.speed);if(1!==this.speed)for(let e=0;e*this.speed<1;e++)await new Promise((e=>this.currentId=t(e)));const e=(-1===this.last?0:(performance.now()-this.last)/1e3)*this.deltaSpeed;for(let t=0;t<this.functions.length;t++)this.functions[t](e);this.last=performance.now();for(let t=0;t<this._updates.length;t++)this._updates[t]+1e3<this.last&&this._updates.splice(t,1);this._updates.push(this.last),this.currentId=t((()=>this.__loop__()))}start(){this.animating||(this.__loop__().then((t=>t)),this.animating=!0)}stop(){this.animating&&(cancelAnimationFrame(this.currentId),clearTimeout(this.currentId),this.animating=!1,this.last=-1)}setUpdateMethod(t){if(!["timeout","frame"].includes(t))throw new Error("Invalid animation method: "+t);this.method=t,this.stop(),this.start()}getUpdateMethod(){return this.method}setSpeed(t){return this.speed=t}setDeltaSpeed(t){this.deltaSpeed=t}getSpeed(){return this.speed}getDeltaSpeed(){return this.deltaSpeed}addFunction(...t){this.functions.push(...t)}removeFunction(...t){for(let e=0;e<t.length;e++)this.functions.splice(this.functions.indexOf(t[e]),1)}getUpdatePerSecond(){return this._updates.length}}const{sin:sin,cos:cos,tan:tan,PI:PI,atan:atan,atan2:atan2,sqrt:sqrt,abs:abs,ceil:ceil,min:min,max:max}=Math;class PhygicEngine extends EventTarget{objects=[];gravityAcceleration=9.801;airDensity=.1;canvas=null;renderOptions={translation:{x:0,y:0},scale:{x:1,y:1}};__animators={update:null,render:null};__canvas_resizer=null;__mouse_events=null;__keyboard_events=null;maxDeltaTime=.5;constructor(t={}){super();const e=["canvas","gravityAcceleration","airDensity","renderOptions"],s=Object.keys(t);for(let i=0;i<e.length;i++){const n=e[i];s.includes(n)&&(this[n]=t[n])}!t.doUpdate&&s.includes("doUpdate")||(this.__animators.update=new PhygicAnimator((t=>this.update(t)))),!t.doRender&&s.includes("doRender")||(this.__animators.render=new PhygicAnimator((()=>this.render()),"frame")),t.resizeCanvas&&this.canvas&&(this.__canvas_resizer=new PhygicCanvasResizer(this.canvas)),t.mouseEvents&&this.canvas&&(this.__mouse_events=new PhygicMouseEvents(this)),t.keyboardEvents&&this.canvas&&(this.__keyboard_events=new PhygicKeyboardEvents(this))}get ctx(){return this.__ctx__&&this.__ctx__.canvas===this.canvas?this.__ctx__:this.__ctx__=this.canvas.getContext("2d")}update(t){t>this.maxDeltaTime&&(t=this.maxDeltaTime);const e=new Event("update");if(e.dt=t,this.dispatchEvent(e),!e.defaultPrevented)for(let e=0;e<this.objects.length;e++)this.objects[e].update(t);const s=new Event("afterUpdate");s.dt=t,this.dispatchEvent(s)}render(){if(!this.canvas)throw new Error("Couldn't find the canvas to render!");const t=new Event("render");if(this.dispatchEvent(t),!t.defaultPrevented){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);for(let t=0;t<this.objects.length;t++)this.objects[t].render()}const e=new Event("afterRender");this.dispatchEvent(e)}addObject(...t){for(let e=0;e<t.length;e++){const s=t[e];this.objects.includes(s)||this.objects.push(s)}}removeObject(...t){for(let e=0;e<t.length;e++)this.objects.splice(this.objects.indexOf(t[e]),1)}get mouseManager(){return this.__mouse_events}get keyboardManager(){return this.__keyboard_events}get mouse(){return new PhygicMouse(this.mouseManager)}get keyboard(){return new PhygicKeyboard(this.keyboardManager)}}class PhygicKeyboardEvents{_listeners=[];constructor(t){this.engine=t,this._keys={},this._lowerKeys={},this.registerEvents()}registerEvents(){const t=(t,e,s=this.engine.canvas)=>{s.addEventListener(t,e),this._listeners.push([s,t,e])};t("keydown",(t=>{this._keys[t.key]=!0,this._lowerKeys[t.key.toLowerCase()]=!0}),window),t("keypress",(t=>{this._keys[t.key]=!0,this._lowerKeys[t.key.toLowerCase()]=!0}),window),t("keyup",(t=>{this._keys[t.key]=!1,this._lowerKeys[t.key.toLowerCase()]=!1}),window),t("blur",(()=>{this._keys={},this._lowerKeys={}}),window)}unregisterEvents(){for(let t=0;t<this._listeners.length;t++)this._listeners[t][0].removeEventListener(this._listeners[t][1],this._listeners[t][2])}}class PhygicKeyboard{constructor(t){this.manager=t}isPressing(t){return!!this.manager._lowerKeys[t.toLowerCase()]}isPressingAbsolute(t){return!!this.manager._keys[t]}}class PhygicModel{object=null;constructor(t={}){const e=["object"],s=Object.keys(t);for(let i=0;i<e.length;i++){const n=e[i];s.includes(n)&&(this[n]=t[n])}}render(){}getCollision(){}collides(t){if(!t)return null;const e=t.getCollision();return e?this.collidesCollision(e):null}collidesCollision(t){return PhygicModel.rawCollision(this.getCollision(),t)}static rawCollision(t,e){if("polygon"!==t[0]||"polygon"!==e[0])return!1;const s=[];for(let e=0;e<t[3].length;e++)s.push([t[3][e][0]+t[1],t[3][e][1]+t[2]]);const i=[];for(let t=0;t<e[3].length;t++)i.push([e[3][t][0]+e[1],e[3][t][1]+e[2]]);function n(t){const e=[];for(let s=0;s<t.length;s++)e.push([t[s],t[(s+1)%t.length]]);return e}function o(t,e){let s=1/0,i=-1/0;for(let n=0;n<t.length;n++){let o=0;for(let s=0;s<t[n].length;s++)o+=t[n][s]*e[s];o<s&&(s=o),o>i&&(i=o)}return[s,i]}const h=[...n(s),...n(i)];for(let t=0;t<h.length;t++){const e=h[t],n=[e[1][1]-e[0][1],-(e[1][0]-e[0][0])],r=o(s,n),a=o(i,n);if(max(r[0],r[1])<min(a[0],a[1])||max(a[0],a[1])<min(r[0],r[1]))return!1}return!0}applyCollisionRotation(t,e){t.velocity[e]=0}getBottomArea(){return 0}}class PhygicCircle extends PhygicModel{fill="black";stroke="";strokeWidth=1;radius=10;constructor(t={}){super(t);const e=["object","radius","fill","stroke","strokeWidth"],s=Object.keys(t);for(let i=0;i<e.length;i++){const n=e[i];s.includes(n)&&(this[n]=t[n])}}render(){if(!this.object)throw new Error("There is no object attached to this model.");this.object.engine.ctx.arc(this.object.x,this.object.y,this.radius,0,2*PI)}getCollision(){if(!this.object)throw new Error("There is no object attached to this model.");return["circle",this.object.x,this.object.y,this.radius]}getBottomArea(){return PI*this.radius}applyCollisionRotation(t,e){t.velocity[e]=0}}class PhygicPath extends PhygicModel{fill="black";stroke="";strokeWidth=1;__path=[];constructor(t={}){super(t);const e=["object","path","fill","stroke","strokeWidth"],s=Object.keys(t);for(let i=0;i<e.length;i++){const n=e[i];s.includes(n)&&(this[n]=t[n])}}recalculateRotatedPath(){if(!this.object)throw new Error("There is no object attached to this model.");if(isNaN(this.object.rotation))return;const t=this.path,e=[];for(let s=0;s<t.length;s++){const i=t[s],n=sin(this.object.rotation),o=sqrt(1-n**2),h=o*i[0]-n*i[1],r=n*i[0]+o*i[1];e[s]=[h,r]}this._rotatedPath=e,this._lastRotation=this.object.rotation}get path(){return this.__path}set path(t){this.__path=t}render(){if(!this.object)throw new Error("There is no object attached to this model.");this._rotatedPath&&this.object.rotation===this._lastRotation||this.recalculateRotatedPath(),this._lastRotation=this.object.rotation;const t=this._rotatedPath;for(let e=0;e<t.length;e++)this.object.engine.ctx[e?"lineTo":"moveTo"](-t[e][0],t[e][1])}getCollision(){if(!this.object)throw new Error("There is no object attached to this model.");return["polygon",this.object.x,this.object.y,this._rotatedPath||this.__path]}getBottomArea(){let t=1/0,e=-1/0;const s=this._rotatedPath||this.path;for(let i=0;i<s.length;i++){const n=s[i][0];n<t&&(t=n),n>e&&(e=n)}return e-t}getEdges(){const t=[],e=this._rotatedPath||this.path;for(let s=0;s<e.length;s++){const i=e[s],n=e[e.length-1===s?0:s+1];t.push([i,n,["polygon",this.object.x,this.object.y,[i,n]]])}return t}applyCollisionRotation(t,e){if(!this.object)throw new Error("There is no object attached to this model.");let s=this.object.rotation;if(t.model instanceof PhygicCircle)s=atan2(t.x-this.object.x,t.y-this.object.y);else if(t.model instanceof PhygicPath){const e=t.model.getEdges();for(let t=0;t<e.length;t++){const[i,n,o]=e[t];if(!this.collidesCollision(o))continue;const h=(n[1]-i[1])/(n[0]-i[0]);abs(h)!==1/0&&(s=h)}}const i=this.object.mass,n=t.mass;if("x"===e){const e=this.object.velocity.x,s=t.velocity.x;this.object.velocity.x=PhygicObject.calculateIntersectionVelocity((t.isStatic,0),i,n,e,s),t.velocity.x=PhygicObject.calculateIntersectionVelocity((this.object.isStatic,0),n,i,s,e)}else{const e=this.object.velocity.y,s=t.velocity.y;this.object.velocity.y=PhygicObject.calculateIntersectionVelocity((t.isStatic,0),i,n,e,s),t.velocity.y=PhygicObject.calculateIntersectionVelocity((this.object.isStatic,0),n,i,s,e)}if(abs(s)!==1/0&&!isNaN(s)){const t=this.object.rotation;this.object.rotation=s,this.object.collidesAny()&&(this.object.rotation=t)}}}class PhygicPolygon extends PhygicPath{_radius=10;constructor(t={}){super(t),t.sides||(t.sides=4);const e=["object","sides","radius"],s=Object.keys(t);for(let i=0;i<e.length;i++){const n=e[i];s.includes(n)&&(this[n]=t[n])}}get radius(){return this._radius}get sides(){return this._sides}set sides(t){this._sides=t;const e=[],s=[],i=this.radius;for(let n=0;n<t;n++){const o=[sin(n/t*PI*2),cos(n/t*PI*2)];e.push(o),s.push([o[0]*i,o[1]*i])}this._poly_path=e,this.path=s}set radius(t){this._radius=t;const e=[];for(let s=0;s<this._poly_path.length;s++){const i=this._poly_path[s];e.push([i[0]*t,i[1]*t])}this.path=e}}class PhygicRectangle extends PhygicPath{_width=0;_height=0;constructor(t={}){super(t),t.width||(t.width=10),t.height||(t.height=10);const e=["object","width","height"],s=Object.keys(t);for(let i=0;i<e.length;i++){const n=e[i];s.includes(n)&&(this[n]=t[n])}}get width(){return this._width}get height(){return this._height}set width(t){this._width!==t&&(this._width=t,this._recalculateRectangle())}set height(t){this._height!==t&&(this._height=t,this._recalculateRectangle())}_recalculateRectangle(){this.path=[[-this.width/2,-this.height/2],[this.width/2,-this.height/2],[this.width/2,this.height/2],[-this.width/2,this.height/2]]}}class PhygicMouseEvents{_listeners=[];constructor(t){this.engine=t,this._mouseDown=!1,this._mousePos=[0,0],this.registerEvents()}get mouseDown(){return this._mouseDown}get mouseX(){return this._mousePos[0]+this.engine.renderOptions.translation.x}get mouseY(){return-this._mousePos[1]+this.engine.renderOptions.translation.y}get absoluteMouseX(){return this._mousePos[0]}get absoluteMouseY(){return this._mousePos[1]}registerEvents(){const t=(t,e,s=this.engine.canvas)=>{s.addEventListener(t,e),this._listeners.push([s,t,e])};t("mousedown",(()=>this._mouseDown=!0)),t("mousemove",(t=>{this._mousePos[0]=t.offsetX,this._mousePos[1]=t.offsetY,this._mouseDown&&(this.engine.renderOptions.translation.x-=t.movementX,this.engine.renderOptions.translation.y+=t.movementY)})),t("mouseup",(()=>this._mouseDown=!1));let e=null;t("touchstart",(t=>e=t.touches[0])),t("touchmove",(t=>{this._mousePos[0]=t.offsetX,this._mousePos[1]=t.offsetY;const s=t.touches[0];this.engine.renderOptions.translation.x-=s.offsetX-e.offsetX,this.engine.renderOptions.translation.y+=s.offsetY-e.offsetY})),t("wheel",(t=>{t.preventDefault(),this.engine.keyboardManager&&this.engine.keyboard.isPressing("control")?(this.engine.renderOptions.scale.x*=t.deltaY,this.engine.renderOptions.scale.y*=t.deltaY):(this.engine.renderOptions.translation.x+=t.deltaX,this.engine.renderOptions.translation.y-=t.deltaY)})),t("blur",(()=>this._mouseDown=!1),window),t("contextmenu",(t=>t.preventDefault()))}unregisterEvents(){for(let t=0;t<this._listeners.length;t++)this._listeners[t][0].removeEventListener(this._listeners[t][1],this._listeners[t][2])}}class PhygicMouse{constructor(t){this.manager=t}get x(){return this.manager.mouseX}get y(){return this.manager.mouseY}get absoluteX(){return this.manager.absoluteMouseX}get absoluteY(){return this.manager.absoluteMouseY}}class PhygicObject{x=0;y=0;rotation=0;velocity={x:0,y:0};force={x:0,y:0};angularVelocity=0;mass=10;kineticFrictionCoefficient=.5;isStatic=!1;model=null;constructor(t,e={}){this.engine=t,t.addObject(this);const s=["x","y","rotation","velocity","angularVelocity","mass","isStatic","model"],i=Object.keys(e);for(let t=0;t<s.length;t++){const n=s[t];i.includes(n)&&(this[n]=e[n],"model"===n&&(e[n].object=this))}}isOnGround(t=.01){this.y-=t;const e=this.collidesAny();return this.y+=t,!!e}update(t){if(this.isStatic)return this.velocity.x=0,void(this.velocity.y=0);this.velocity.y-=this.engine.gravityAcceleration*t;const e=this.engine.airDensity*this.getBottomArea()*this.velocity.y**2/this.mass*t;if(this.velocity.y<0&&(-this.velocity.y>e?this.velocity.y+=e:this.velocity.y=0),abs(this.velocity.x)>1e-5){if(this.isOnGround()){const e=this.velocity.x>0,s=(e?-1:1)*this.kineticFrictionCoefficient*this.engine.gravityAcceleration*cos(this.rotation)*t;this.velocity.x+=s,e!==this.velocity.x>0&&(this.velocity.x=0)}this.move(this.velocity.x,0)}abs(this.velocity.y)>1e-5&&this.move(0,this.velocity.y),this.y<-500&&(this.y=-500,this.velocity.y=0),this.rotation+=this.angularVelocity*t,this.move(0,0).any&&(this.rotation-=this.angularVelocity*t)}render(){if(!this.model)return;this.model.object=this;const t=this.engine,e=t.ctx;e.save(),e.translate(this.x-t.renderOptions.translation.x,-this.y+t.renderOptions.translation.y),e.scale(t.renderOptions.scale.x,t.renderOptions.scale.y),e.beginPath(),e.fillStyle=this.model.fill,e.strokeStyle=this.model.stroke,e.lineWidth=this.model.strokeWidth,this.model.render(),this.model.fill&&e.fill(),this.model.stroke&&e.stroke(),e.closePath(),e.restore()}collides(t){return this.model?this.model.collides(t.model):null}collidesAny(){const t=this.engine.objects;for(let e=0;e<t.length;e++){const s=t[e];if(s!==this&&this.collides(s))return s}return null}move(t,e){const s=atan2(t,e),i=sqrt(t**2+e**2),n=[sin(s)*i/30,cos(s)*i/30],o={x:null,y:null};for(let t=0;t<30;t++){if(!o.x){this.x+=n[0];let t=this.collidesAny();t&&(this.model.applyCollisionRotation(t,"x"),o.x=t,this.x-=n[0])}if(!o.y){this.y+=n[1];let t=this.collidesAny();t&&(this.model.applyCollisionRotation(t,"y"),o.y=t,this.y-=n[1])}if(o.x&&o.y)break}return o.any=o.x||o.y,o}getBottomArea(){return this.model?this.model.getBottomArea():0}getRadianTo(t,e){return atan2(t-this.x,e-this.y)}turnAt(t,e){this.rotation=this.getRadianTo(t,e)}getDirectionVectorTo(t,e){const s=this.getRadianTo(t,e);return{x:sin(s),y:cos(s)}}getDirectionVector(){return{x:sin(this.rotation),y:cos(this.rotation)}}static calculateIntersectionVelocity(t,e,s,i,n){return(t*s*(n-i)+e*i+s*n)/(e+s)}static calculateDirectionVector(t,e,s,i){const n=atan2(t-s,e-i);return[sin(n),cos(n)]}}class PhygicCanvasResizer{__listener;constructor(t,e=!0,s=!0){this.canvas=t,this.maximize=e,this.center=s}get maximize(){return this._maximize}set maximize(t){t!==this._maximize&&(this._maximize=t,this.__listener&&removeEventListener("resize",this.__listener),t?(addEventListener("resize",this.__listener=()=>{this.canvas.width=innerWidth,this.canvas.height=innerHeight}),this.canvas.width=innerWidth,this.canvas.height=innerHeight,this.canvas.style.width="100%",this.canvas.style.height="100%"):(this.canvas.style.width="",this.canvas.style.height=""))}get center(){return this._center}set center(t){t!==this._center&&(this._center=t,t?(this.canvas.style.position="absolute",this.canvas.style.left="0",this.canvas.style.top="0"):(this.canvas.style.position="",this.canvas.style.left="",this.canvas.style.top="",this.canvas.style.transform=""))}}